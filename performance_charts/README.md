# Performance Charts Directory

This directory contains all the performance charts generated by the Graph Performance Benchmark.

## Chart Overview

### Task 1 Charts (Basic Graph Operations)
- **task1_addVertex_performance.png** - Performance of adding vertices to graphs
- **task1_addEdge_performance.png** - Performance of adding edges to graphs  
- **task1_hasVertex_performance.png** - Performance of checking vertex existence
- **task1_hasEdge_performance.png** - Performance of checking edge existence
- **task1_getEdge_performance.png** - Performance of retrieving edges between vertices
- **task1_getEdgeLength_performance.png** - Performance of getting edge lengths

### Task 2 Charts (Advanced Graph Operations)
- **task2_getTotalEdgeLength_performance.png** - Performance of calculating total edge length
- **task2_removeEdge_performance.png** - Performance of removing edges
- **task2_remove_performance.png** - Performance of removing vertices
- **task2_getVertices_performance.png** - Performance of retrieving all vertices
- **task2_getEdges_performance.png** - Performance of retrieving all edges
- **task2_getNeighbors_performance.png** - Performance of retrieving vertex neighbors

### Task 3 Charts (Algorithm Operations)
- **task3_shortestPath_performance.png** - Performance of Dijkstra's shortest path algorithm
- **task3_pathLength_performance.png** - Performance of path length calculation
- **task3_getNeighborsRange_performance.png** - Performance of range-based neighbor search
- **task3_performance_summary.png** - Summary comparison of Task 3 algorithms (500 vertex graph)

### Summary Chart
- **performance_comparison_summary.png** - Comprehensive comparison of ALGraph vs AMGraph performance across all methods (2000 vertex graph)

## How to Interpret the Charts

### Line Charts (Task 1 & Task 2)
- **X-axis**: Graph size (number of vertices)
- **Y-axis**: Average time per operation (nanoseconds)
- **Lines**: 
  - Blue line = ALGraph (Adjacency List)
  - Red line = AMGraph (Adjacency Matrix)

### Bar Chart (Summary)
- **X-axis**: Method names
- **Y-axis**: Average time per operation (nanoseconds)
- **Bars**: 
  - Blue bars = ALGraph
  - Red bars = AMGraph

## Key Performance Insights

### ALGraph Advantages:
- Better performance for `getNeighbors()` and `getEdges(vertex)` operations
- Superior performance for vertex removal in sparse graphs
- More consistent performance across different graph densities

### AMGraph Advantages:
- Faster `getEdgeLength()` due to direct matrix access
- Better performance for `hasEdge(vertices)` and `addEdge()` operations
- More predictable performance for vertex removal in dense graphs

### Critical Performance Differences:
- **getEdge**: AMGraph is significantly slower (O(E) vs O(deg(v))) for dense graphs
- **getNeighbors**: AMGraph is much slower (O(V*deg(v)) vs O(deg(v))) for high-degree vertices
- **remove(vertex)**: ALGraph is faster for sparse graphs, AMGraph for dense graphs
- **shortestPath**: Both implementations show similar performance with Dijkstra's algorithm
- **getNeighbors(range)**: ALGraph generally performs better for range-based searches
- **pathLength**: Both implementations perform similarly as it's a simple path traversal

## Test Parameters

### Task 1 & 2 Parameters:
- **Graph sizes tested**: 10, 50, 100, 200, 500, 1000, 2000 vertices
- **Warmup iterations**: 1,000 per method
- **Measurement iterations**: 10,000 per method
- **Edge density**: Varies by task (sparse for Task 1, denser for Task 2)

### Task 3 Parameters:
- **Graph sizes tested**: 10, 25, 50, 100, 200, 500 vertices (smaller due to algorithm complexity)
- **Warmup iterations**: 500 per method (reduced for complex algorithms)
- **Measurement iterations**: 2,000 per method (reduced for complex algorithms)
- **Edge density**: Connected graphs with additional edges (25% extra edges)
- **Range values tested**: 1, 5, 10, 20, 50 for getNeighbors(range)

## Usage Recommendations

- **Use ALGraph for**: Sparse graphs, frequent neighbor queries, vertex removals
- **Use AMGraph for**: Dense graphs, frequent edge length queries, edge existence checks
- **Hybrid approach**: Consider using both representations for different operations in the same application

## Regenerating Charts

To regenerate Task 1 & 2 charts, run:
```bash
./gradlew runBenchmark
```

To regenerate Task 3 charts, run:
```bash
./gradlew runTask3Benchmark
```

The charts will be automatically organized into this directory. 